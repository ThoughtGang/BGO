#!/usr/bin/env ruby
# :title: Bgo::Instruction
=begin rdoc
BGO Instruction object

Copyright 2013 Thoughtgang <http://www.thoughtgang.org>

An instruction is an assembly language instruction.

===General Usage

# 1. Obtain isa, category, and operations from opcode metadata table
# 2. Create an Opcode object for the mnemonic
opcode = Opcode.new(mnemonic, isa, cat, op)
# 3. Create an Instruction object to associate the Opcode and operands
insn = Instruction.new( ascii, opcode, prefixes ) 
# 4. Create an Operand object for each operand, and add to instruction
operands.each do |o|
   # 4a. Instantiate Operand from a factory method 
   op = operand_from_string(o)
   # 4b. Set operand access based on instruction
   # 4c. Add operand to instruction
   insn.operands << op
   # 4d. Set operand dest/src/target label in instruction
end
=end

require 'bgo/address_contents'

# prevent circular requires caused by autoload
class Bgo::Instruction < Bgo::AddressContents; end
class Bgo::Opcode; end
class Bgo::Operand; end
class Bgo::Register; end
class Bgo::IndirectAddress; end

require 'bgo/metadata/instruction'

module Bgo

=begin rdoc
An assembly language instruction.

This associates an Opcode object with an OperandList object to represent a
disassembled instruction for a specific byte sequence.

An Instruction object is considered to be an instance-of an Opcode object. It
consists of an Opcode object and an OperandList of zero or more Operand
objects. Each Opcode object and each Operand object can be considered a
Singleton object, and may be stored as such in the backend database in order
to conserve space.
=end
  class Instruction < AddressContents
    register_content_type(:code)
 
=begin rdoc
The architecture to which the instruction belongs. This is purely descriptive.
When indexing instruction descriptions (e.g. for singleton descriptions), 
arch + ascii would be the primary key of an instruction.
=end
    attr_reader :arch

=begin rdoc
The ASCII rendition of the instruction. This is used to identify the
instruction, and is immutable.
=end
    attr_reader :ascii

=begin rdoc
The opcode of the instruction.
=end
    attr_reader :opcode

=begin rdoc
Array of instruction prefixes (strings)
=end
    attr_reader :prefixes

=begin rdoc
List of side effects for this combination of Opcode and Operands (e.g.
stack modification, heap modification, etc).

NOT IMPLEMENTED
=end
    attr_reader :side_effects

=begin rdoc
A list of operands for the instruction
=end
    attr_reader :operands

=begin rdoc
A user-supplied comment. Note that this is a comment for all occurrences of
an instruction, not a comment for an instruction at an address. For the latter,
comment the Address object.
=end
    attr_accessor :comment

    # ----------------------------------------------------------------------
=begin rdoc
Note: operands are added after instantiation.
=end
    def initialize( arch, ascii, opcode, prefixes=[], effects=[] )
      @arch = arch
      @ascii = ascii
      @opcode = opcode
      @operands = OperandList.new
      @prefixes = [ (prefixes || []) ].flatten 
      @side_effects = [ (effects || []) ].flatten
    end
    
=begin rdoc
Is instruction a branch (JMP or CALL) ?
=end
    def branch?
      opcode.branch?
    end

=begin rdoc
Does execution continue to the address after this instruction (not JUMP or RET)?
=end
    def fallthrough?
      opcode.fallthrough?
    end

=begin rdoc
Operand labelled 'destination' operand.
=end
    def dest
      operands.dest
    end

=begin rdoc
Operand labelled 'source' operand.
=end
    def src
      operands.src
    end

=begin rdoc
Operand labelled 'target' operand.
=end
    def target
      operands.target
    end
    
    # ----------------------------------------------------------------------

=begin rdoc
Return ASCII representation of instruction, as generated by the original
disassembler.

Note: This is intended for introspection and debugging, not for creating
assembly-language output.
=end
    def to_s
      self.ascii
    end

    def inspect
      str = prefixes.count > 0 ? prefixes.inspect + ' ' : ''
      str << opcode.inspect
      str << "( #{operands.inspect} )"
    end

    # ----------------------------------------------------------------------

    def to_core_hash
      {
        :ascii => ascii,
        :arch => arch,
        :comment => comment,
        :prefixes => prefixes,
        :side_effects => side_effects
      }
    end

    def to_hash
      to_core_hash.merge( { :opcode => opcode.to_hash,
                            :operands => operands.to_hash } )
    end
    alias :to_h :to_hash

    def fill_from_hash(h)
      @comment = h[:comment].to_s
      @operands = OperandList.from_hash h[:operands]
      self
    end

    def self.from_hash(h)
      return nil if (! h) or (h.empty?)
      self.new( h[:arch].to_s, h[:ascii].to_s, Opcode.from_hash(h[:opcode]), 
                (h[:prefixes] || []).map { |p| p.to_s }, 
                (h[:side_effects] || []).map { |e| e.to_sym } 
              ).fill_from_hash(h)
    end

  end

# ----------------------------------------------------------------------
=begin rdoc
An assembly language opcode.
This should be considered the canonical definition of the instruction operation,
and contains all metadata for the actual instruction (i.e. the operator, not
the operands).
=end
  class Opcode

=begin rdoc
Mnemonic for the opcode, e.g. 'add'.
=end
    attr_reader :mnemonic
    alias :ascii :mnemonic

=begin rdoc
ISA subset for the opcode.
=end
    attr_reader :isa

=begin rdoc
The nature of the instruction. This is a very broad hint regarding the
effects of the instruction: is it used for control-flow, to modify the
stack, etc.
Note that this refers only to the opcode of the instruction, not to the
operands. Thus, an instruction like "add [esp], 10" would have a MATH
category, not a STACK category. The Instruction@side_effects member is
used to store side effects caused by the combination of opcode and
operands.
=end
    attr_reader :category

=begin rdoc
The operation performed by the instruction. Generally, this is a hint regarding
the instruction effects more than anything else.
Since a CISC operation can have more than one effect, this is an array. The
operation accessor returns the first operation.
=end
    attr_reader :operations

=begin rdoc
Array of flags read by instruction.
=end
    attr_reader :flags_read
=begin rdoc
Array of flags modified by instruction.
=end
    attr_reader :flags_set

    def initialize( mnemonic, isa, cat, op=OP_UNK, flags_read=[], flags_set=[] )
      @mnemonic = mnemonic 
      @isa = isa
      @category = cat
      @operations = [(op || OP_UNK)].flatten
      @flags_read = [(flags_read || [])].flatten
      @flags_set = [(flags_set || [])].flatten
    end

=begin rdoc
Return the default (first) operation for the instruction.
=end
    def operation
      operations.first
    end

=begin rdoc
Strip invalid flags from flags array.
=end
    def self.validate_flags(flags)
      return [] if not flags
      flags.reject { |f| not FLAGS.include? f }
    end

=begin rdoc
Returns true if the instruction is a branch (is a CALL, CALLCC, JMP, or
JMPCC).
=end
    def branch?
      (operations.include?(OP_CALL) || operations.include?(OP_CALLCC) ||
       operations.include?(OP_JMP) || operations.include?(OP_JMPCC) )
    end

=begin rdoc
Returns true if execution falls through to the next instruction. This is true
in all cases except JMP and RET.
=end
    def fallthrough?
      (! (operations.include?(OP_JMP) || operations.include?(OP_RET)))
    end

    # ----------------------------------------------------------------------
    def to_s
      self.mnemonic
    end

    def inspect
      "#{mnemonic} {#{isa}, #{category}, #{operations}}"
    end

    # ----------------------------------------------------------------------
    # Serialization

    def to_hash
      {
        :mnemonic => mnemonic,
        :isa => isa,
        :category => category,
        :operations => operations,
        :flags_tested => flags_read,
        :flags_set => flags_set
      }
    end
    alias :to_h :to_hash

    def self.from_hash(h)
      return nil if (! h) or (h.empty?)
      self.new( h[:mnemonic].to_s, h[:isa].to_s, h[:category].to_sym, 
                (h[:operations] || []).map { |o| o.to_sym }, 
                (h[:flags_tested] || []).map { |f| f.to_sym }, 
                (h[:flags_set] || []).map { |f| f.to_sym } )
    end

  end

# ----------------------------------------------------------------------
=begin rdoc
List of operands to an opcode. This associates Operand objects with an 
Opcode object for an Instruction object (instance of an Opcode).
=end
  class OperandList < Array

=begin rdoc
The destination operand of an instruction. This has access 'w' and possibly 'r'.
=end
    attr_writer :dest
=begin rdoc
The source operand of an instruction. This has access 'r'.
=end
    attr_writer :src
=begin rdoc
The target operand of a branch instruction. This has access 'x'.
=end
    attr_writer :target
=begin rdoc
Array of access strings (rwx) for each Operand.
=end
    # TODO: this needs to be easier to test, e.g. 0,1,2,4 converted to 
    #       rwx string for display
    attr_reader :access

    def initialize(*args)
      @dest, @src, @target = nil, nil, nil    # suppress warnings
      @access = []
      super
    end

=begin rdoc
Return the destination operand.
=end
    def dest
      @dest ? self.[](@dest) : nil
    end

=begin rdoc
Return the index of the dest operand.
=end
    def dest_index
      @dest
    end

=begin rdoc
Return the source operand.
=end
    def src
      @src ? self.[](@src) : nil
    end

=begin rdoc
Return the index of the src operand.
=end
    def src_index
      @src
    end

=begin rdoc
Return the target operand, i.e. of a jump or call.
=end
    def target
      @target ? self.[](@target) : nil
    end

=begin rdoc
Return the index of the target operand.
=end
    def target_index
      @target
    end

    def each_with_access(&block)
      self.each_with_index { |op, idx| yield(op, (@access[idx] || '---')) }
    end

    # ----------------------------------------------------------------------
    def inspect
      # TODO: access
      str = '['
      self.each_with_index do |op, idx|
        str << ', ' if idx > 0
        name = operand_name(idx)
        str << "#{name}: " if name
        str << op.inspect
      end

      str << ']'
    end

    # ----------------------------------------------------------------------

    def to_core_hash
      {
        :dest => dest_index,
        :src => src_index,
        :target => target_index,
        :access => access
      }
    end

    def to_hash
      to_core_hash.merge( { :operands => map { |op| op.to_hash } } )
    end
    alias :to_h :to_hash

    def fill_from_hash(h)
      return self if (! h) or (h.empty?)
      ops = self
      h[:operands].each { |op| ops << Operand.from_hash(op) }
      @dest = h[:dest].to_i
      @src = h[:src].to_i
      @target = h[:target].to_i
      @access = (h[:access] || []).map { |a| a.to_sym }
      self
    end

    def self.from_hash(h)
      self.new.fill_from_hash(h)
    end

    private

    def operand_name(idx)
      return 'target' if idx == @target
      return 'dest' if idx == @dest
      return 'src' if idx == @src
      nil
    end

  end

# ----------------------------------------------------------------------
=begin rdoc
An operand to an opcode.
=end
  class Operand

=begin rdoc
ASCII representation ("mnemonic") of Operand.
=end
    attr_reader :ascii
=begin rdoc
can be numeric, register, address, expression, absolute address
=end
    attr_reader :value

    def initialize(ascii, value)
      @ascii = ascii
      @value = value
    end

=begin rdoc
Is operand an immediate value?
=end
    def immediate?
      value.kind_of? Fixnum
    end

=begin rdoc
Is operand a register value?
=end
    def register?
      value.kind_of? Bgo::Register
    end

=begin rdoc
Is operand a memory address?
Note: This returns true if the operand is an indirect address. It does not 
return true for immediate values which happen to be memory addresses.
=end
    def memory?
      value.kind_of? Bgo::IndirectAddress
    end

    # ----------------------------------------------------------------------
    def to_s
      self.ascii
    end

    def inspect
      value.inspect
    end

    # ----------------------------------------------------------------------

    def to_hash
      {
        :ascii => ascii,
        :value_type => value.class.name,
        :value => (value.respond_to? :to_hash) ? value.to_hash : value
      }
    end
    alias :to_h :to_hash

    def self.value_from_hash(h)
      case (h[:value_type] || '')
      when Register.name
        Register.from_hash h[:value]
      when IndirectAddress.name
        IndirectAddress.from_hash h[:value]
      when Fixnum.name, Bignum.name
        (h[:value] || 0).to_i
      when Float.name
        (h[:value] || 0).to_f
      else
        nil
      end
    end

    def self.from_hash(h)
      return nil if (! h) or (h.empty?)
      val = value_from_hash h
      self.new(h[:ascii].to_s, val)
    end
  end

# ----------------------------------------------------------------------
=begin rdoc
A CPU Register. This includes the register name and all metadata associated
with the register.

Note that this is only used for identification and description; it does not
store the value of the register.
=end

  class Register

=begin rdoc
Mnemonic or logical name for the register.
=end
    attr_reader :mnemonic
    alias :ascii :mnemonic
=begin rdoc
The size of the register in bytes.
=end
    attr_reader :size
=begin rdoc
The type of the register. This can imply what ISA subset the register is part 
of, e.g. FPU or SIMD.
=end
    attr_reader :type

=begin rdoc
Array of purposes (strings).
The use to which the register is generally put. A register can have
multiple purposes. The disassembler can add arbitrary purpose strings.
=end
    attr_reader :purpose

=begin rdoc
Identifier for hardware register (e.g. 1 for RAX, EAX, AX, AH, and AL on x86).
This allows tracking of logical registers that modify the same hadrware
register. On x86, MMX and FPU registers will have the same ID.
=end
    attr_reader :id
=begin rdoc
A binary mask of the bits that are significant for this register.
On x86, EAX would be 0xFFFFFFFF, AX would be 0xFFFF, AH would be 0xFF00,
and AL would be 0xFF. Note that the shift is implicit in the mask.
=end
    attr_reader :mask

    def initialize(mnemonic, id, mask, size, type, purpose)
      @mnemonic = mnemonic
      @id = id
      @mask = mask
      @size = size
      @type = type
      @purpose = [purpose].flatten          # allow single purpose or array
    end

=begin rdoc
Extract the register contents from the given (presumably machine-word) value. 
This performs all necessary mask and shift operations on 'value', which is 
assumed to be a  machine-word register (e.g. eax on x86 where the register
object is eax, ax, ah, or al).

Examples:

  r_eax.extract(0x12345678) # returns 0x12345678
  r_ax.extract(0x12345678)  # returns 0x45678
  r_ah.extract(0x12345678)  # returns 0x56
  r_al.extract(0x12345678)  # returns 0x78
=end
    def extract(value)
      return value if (not mask) || mask == ((2**(8*size)) - 1)
      val = value & mask
      m = mask
      # for size*8 bits, shift mask (and val) until there are no more 0s
      (size*8).times { x = m & 0x1; break if x != 0; m >>= 1; val >>= 1 }
      val
    end

=begin rdoc
Apply new_value to old_value as if setting the contents of this register.
This performs all necessary mask and shift operations. The new value of the 
machine-word register (e.g. eax on x86 where the register object is eax, ax,
ah, or al) is returned.

Examples:

  r_eax.apply(0x12345678, 0xCCCCCCCC) # returns 0xCCCCCCCC
  r_ax.apply(0x12345678, 0xCCCC)      # returns 0x1234CCCC
  r_ah.apply(0x12345678, 0xCC)        # returns 0x1234CC78
  r_al.apply(0x12345678, 0xCC)        # returns 0x123456CC
=end
    def apply(old_value, new_value)
      size_mask = (2**(8*size)) - 1
      nv = new_value & size_mask
      if (size_mask != mask)
        m = mask
        # for size*8 bits, shift mask (and new-val) until there are no more 0s
        (size*8).times do 
          x = m & 0x1       # get low bit in mask
          break if x != 0   # if ! 0, then no need to keep shifting
          nv <<= 1          # left-shift new_value by one bit
          size_mask <<= 1   # left shift mask for register by one bit
          m >>= 1           # advance to next bit in mask
        end
      end

      (old_value ^ size_mask) | nv
    end

    # ----------------------------------------------------------------------
    def to_s
      self.mnemonic
    end

    def inspect
      "{ mnem: '%s', id: %d, mask: 0x%X, size: %d, type: %s, purpose: [%s] }"\
        % [self.mnemonic, self.id, self.mask, self.size, self.type.to_s,
           self.purpose.map{ |x| x.to_s }.join(',')]
    end

    # ----------------------------------------------------------------------

    def to_hash
      {
        :mnemonic => mnemonic,
        :id => id,
        :mask => mask,
        :size => size,
        :type => type,
        :purpose => purpose
      }
    end
    alias :to_h :to_hash

    def self.from_hash(h)
      return nil if (! h) or (h.empty?)
      self.new(h[:mnemonic].to_s, h[:id].to_i, h[:mask].to_i, h[:size].to_i, 
               h[:type].to_sym, (h[:purpose] || []).map { |p| p.to_sym } )
    end
  end

# ----------------------------------------------------------------------
=begin rdoc
An indrect address object. This generally occurs only as an Operand value. It
can contain one or more Register objects. In Intel literature, this is
also referred to as an 'effective address'.

The general format for an indirect address is:
  segment : displacement + (base + shift_op(index, scale) )
...where shift_op is generally ASL (arithmetic-shift-left) unless overridden
(e.g. on ARM).
=end
  class IndirectAddress

=begin rdoc
Scale factor (default is 1)
=end
    attr_reader :scale
=begin rdoc
Index register (gets shifted by scale value)
=end
    attr_reader :index
=begin rdoc
Base register.
=end
    attr_reader :base
=begin rdoc
Shift operation. All but the default (ASL) generally apply only to ARM.
=end
    attr_reader :shift

=begin rdoc
Displacement value
=end
    attr_reader :displacement
    alias :disp :displacement

=begin rdoc
Segment register to apply to displacement
=end
    attr_reader :segment
    alias :seg :segment

    def initialize(disp, base, index, scale=1, segment=nil, shift=SHIFT_ASL)
      @displacement = disp ? disp : 0
      @base = base
      @index = index
      @scale = scale
      @segment = segment
      @shift = shift
    end

=begin rdoc
Returns true if this is a fixed address (i.e. a displacement or 
segment:displacement)
=end
    def fixed?
      @displacement and (not @base) and (not @index)
    end

    # ----------------------------------------------------------------------
    def to_s
      str = @segment ? @segment.ascii + ';' : ''
      str << ("0x%X" % @displacement) if @displacement > 0
      str << " + " if (@displacement > 0) && (@base or @index)
      str << "[" if @base or @index
      str << @base.ascii if @base
      str << "+" if @base and @index
      str << @index.ascii if @index
      str << "*#{@scale}" if (@index and (@scale > 1))
      str << "]" if @base or @index
      str
    end

    def inspect
      to_s
      "{ base: %s, index: %s, scale: %d, disp: 0x%X, segment: %s, shift: %s }" %
      [self.base.inspect, self.index.inspect, self.scale, self.displacement,
       self.segment.inspect, self.shift]
    end

    # ----------------------------------------------------------------------

    def to_hash
      {
        :displacement => displacement,
        :base => base ? base.to_hash : nil,
        :index => index ? index.to_hash : nil,
        :scale => scale,
        :segment => segment ? segment.to_hash : nil,
        :shift => shift
      }
    end
    alias :to_h :to_hash

    def self.from_hash(h)
      return nil if (! h) or (h.empty?)
      base = h[:base] ? Register.from_hash(h[:base]) : nil
      index = h[:index] ? Register.from_hash(h[:index]) : nil
      seg = h[:segment] ? Register.from_hash(h[:segment]) : nil
      shift = h[:shift].to_sym
      self.new( h[:displacement].to_i, base, index, h[:scale].to_i, seg, shift )
    end

  end

end
