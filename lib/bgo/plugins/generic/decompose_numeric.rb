#!/usr/bin/env ruby
# :title: DecomposeNumeric Plugin
=begin rdoc
BGO plugin to decompose a binary String into all possible numeric 
interpretations (byte, short, hword, word, float, double).

Copyright 2013 Thoughtgang <http://www.thoughtgang.org>
=end

require 'bgo/application/plugin'
require 'bgo/ident'

module Bgo
  module Plugins
    
    module Generic
      class DecomposeNumeric
        extend Bgo::Plugin

        # ----------------------------------------------------------------------
        # DESCRIPTION
        name 'Decompose-Numeric'
        author 'dev@thoughtgang.org'
        version '0.2'
        description 'Convert binary String to all possible numeric primitives.'
        help 'Decompose-Numeric Plugin
Decode a binary String into numeric primitives (C types char, short, int, long 
long, float, double).

This decodes every possible permutation of the String: both big- and 
little-endian byte order, both signed and unsigned integer values, and
every possible alignment (0..1 for two-byte types, 0..3 for four-byte types,
and 0..7 for eight-byte types).

The results stored as an array of (unpacked) numbers in a Hash; the Hash
specifies the type, signedness, endianness, and alignment used to decode the
data array.
        
Note that all arrays for a type are nil-padded in order to have equal length.
This is necessary because interpreting a buffer as a multibyte value at 
different offsets will result in a one-byte difference between offsets due to 
the change in alignment.

For example the following buffer, 
  00 00 00 00 00 00 00 00 00    # 9 NULL bytes
would be decomposed into the following arrays for a signed 4-byte integer:
  offset 0: [0, 0]     # 4-byte values at index 0, 4; 1 byte  remains
  offset 1: [0, 0]     # 4-byte values at index 1, 5; 0 bytes remain
  offset 2: [0, nil]   # 4-byte value  at index 2;    3 bytes remain
  offset 3: [0, nil]   # 4-byte value  at index 3;    2 bytes remain
'

        # ----------------------------------------------------------------------
        # API

        api_doc :decompose_numeric, ['String'], 'Hash', \
                'Convert String to all possible numeric primitives.'

=begin rdoc
Decode bytes in String to all supported primitives in all possible permutations.
=end
        def decompose_numeric(str)
          [ every_byte(str), every_two_bytes(str), every_four_bytes(str),
            every_eight_bytes(str) ].flatten.inject({}) do |h, t|
            h[hash_name(t)] = t[:data]
            h
          end
        end

        # ----------------------------------------------------------------------
        # endian constants
        END_A = ENDIAN_ANY = :any
        END_L = ENDIAN_LITTLE = :little
        END_B = ENDIAN_BIG = :big

        # unpacking formats
        # {:l => len, :t => type, :e => endian, :sign => sign bit, :n => name}
        T_1U ={:l => 1, :t => 'C',  :e => END_A, :s => false, :n =>'int 1-byte'}
        T_1S ={:l => 1, :t => 'c',  :e => END_A, :s => true,  :n =>'int 1-byte'}
        T_2BU={:l => 2, :t => 'S>', :e => END_B, :s => false, :n =>'int 2-byte'}
        T_2LU={:l => 2, :t => 'S<', :e => END_L, :s => false, :n =>'int 2-byte'}
        T_2BS={:l => 2, :t => 's>', :e => END_B, :s => true,  :n =>'int 2-byte'}
        T_2LS={:l => 2, :t => 's<', :e => END_L, :s => true,  :n =>'int 2-byte'}
        T_4BU={:l => 4, :t => 'L>', :e => END_B, :s => false, :n =>'int 4-byte'}
        T_4LU={:l => 4, :t => 'L<', :e => END_L, :s => false, :n =>'int 4-byte'}
        T_4BS={:l => 4, :t => 'l>', :e => END_B, :s => true,  :n =>'int 4-byte'}
        T_4LS={:l => 4, :t => 'l<', :e => END_L, :s => true,  :n =>'int 4-byte'}
        T_4BF={:l => 4, :t => 'g',  :e => END_B,:s => false,:n =>'float 4-byte'}
        T_4LF={:l => 4, :t => 'e',  :e => END_L,:s => false,:n =>'float 4-byte'}
        T_8BU={:l => 8, :t => 'Q>', :e => END_B, :s => false, :n =>'int 8-byte'}
        T_8LU={:l => 8, :t => 'Q<', :e => END_L, :s => false, :n =>'int 8-byte'}
        T_8BS={:l => 8, :t => 'q>', :e => END_B, :s => true,  :n =>'int 8-byte'}
        T_8LS={:l => 8, :t => 'q<', :e => END_L, :s => true,:n =>'int 8-byte'}
        T_8BF={:l => 8, :t => 'G',  :e => END_B,:s => false,:n =>'float 8-byte'}
        T_8LF={:l => 8, :t => 'E',  :e => END_L,:s => false,:n =>'float 8-byte'}

        # type-definitions which can be unpacked for each n-byte chunk
        TYPES_FOR_BYTE_SIZE = {
          1 => [ T_1U, T_1S ],
          2 => [ T_2BU, T_2LU, T_2BS, T_2LS ],
          4 => [ T_4BU, T_4LU, T_4BS, T_4LS, T_4BF, T_4LF ],
          8 => [ T_8BU, T_8LU, T_8BS, T_8LS, T_8BF, T_8LF ]
        }

        # type-codes for floats
        FLOAT_TYPES = [ 'g', 'G', 'e', 'E' ]

=begin rdoc
Generate a name for a Hash (generated by hash_for_type).
=end
      def hash_name(h)
        sign = (FLOAT_TYPES.include? h[:pack_code]) ? '' : \
                                  (h[:signed] ? 's' : 'u')
        endian = (h[:endian] == ENDIAN_BIG) ? '_big' : \
                                ((h[:endian] == ENDIAN_LITTLE) ? '_lit' : '')
        "%s%s%s_%d" % [sign, h[:basename].gsub(/\s/, '_').gsub('-', ''), 
                       endian, h[:align].to_s]
      end

=begin rdoc
Returns a Hash with settings for the given type object (one of the T_* constants
given above).
=end
        def hash_for_type(type, align)
          h = { :basename => type[:n], :pack_code => type[:t], 
                :size => type[:l], :endian => type[:e], :signed => type[:s], 
                :align => align, :data => [] }
          h[:float] = (FLOAT_TYPES.include? h[:pack_code])  # otherwise, int
          h[:name] = hash_name(h)
          h
        end

=begin rdoc
Unpack byte according to Hash (created with hash_for_type) preferences and
append to data array in Hash.
=end
        def hash_unpack_and_append(h, buf)
          val = buf.unpack(h[:pack_code]).first
          # strip NaNs from floating-point conversion
          val = nil if ((FLOAT_TYPES.include? h[:pack_code]) && val.nan?)
          h[:data] << val
        end

=begin rdoc
Unpack and append every n bytes in buffer. This auto-generates the hashes for
each type using hash_for_type.
=end
        def every_n_bytes(buf, n)
          raise "Unsupported num #{n}" if (! TYPES_FOR_BYTE_SIZE.include? n)
          return [] if n > buf.length

          arr = []
          n.times do |i|
            hashes = TYPES_FOR_BYTE_SIZE[n].map {|type| hash_for_type(type, i) }
            buf[i..-1].scan(/.{#{n}}/).each do |str|
              hashes.each { |h| hash_unpack_and_append(h, str) }
            end
            arr.concat hashes
          end

          # NULL-pad arrays that are off by one element
          max = arr.map { |h| h[:data].length }.max
          arr.select { |h| h[:data].length < max }.each { |h| h[:data] << nil }
          arr
        end

=begin rdoc
Unpack and append every 8 bytes in buffer. This wrap every_n_bytes.
=end
        def every_eight_bytes(buf)
          every_n_bytes(buf, 8)
        end

=begin rdoc
Unpack and append every 4 bytes in buffer. This wrap every_n_bytes.
=end
        def every_four_bytes(buf)
          every_n_bytes(buf, 4)
        end

=begin rdoc
Unpack and append every 2 bytes in buffer. This wrap every_n_bytes.
=end
        def every_two_bytes(buf);
          every_n_bytes(buf, 2)
        end

=begin rdoc
Unpack every byte in buffer as a signed and an unsigned int. This returns
two Hashes, one for signed bytes and one for unsigned bytes.
=end
        def every_byte(buf)
          h_u = hash_for_type( T_1U, 0)
          h_s = hash_for_type( T_1S, 0)
          buf.chars.each do |c|
            h_u[:data] << c.ord
            h_s[:data] << c.unpack('c').first
          end
          [h_u, h_s]
        end

      end

    end
  end
end

